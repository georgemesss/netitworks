# -*- text -*-
#
#  main/mysql/queries.conf-- MySQL configuration for default schema (schema.sql)
#
#  $Id: 51560a71ed819a95bc0f5ccc352efe69e374f7c5 $

# Use the driver specific SQL escape method.
#
# If you enable this configuration item, the "safe_characters"
# configuration is ignored.  FreeRADIUS then uses the MySQL escape
# functions to escape input strings.  The only downside to making this
# change is that the MySQL escaping method is not the same the one
# used by FreeRADIUS.  So characters which are NOT in the
# "safe_characters" list will now be stored differently in the database.
#
#auto_escape = yes

# Safe characters list for sql queries. Everything else is replaced
# with their mime-encoded equivalents.
# The default list should be ok
# Using 'auto_escape' is preferred
safe_characters = "@abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-_: /"

#######################################################################
#  Connection config
#######################################################################
# The character set is not configurable. The default character set of
# the mysql client library is used. To control the character set,
# create/edit my.cnf (typically in /etc/mysql/my.cnf or /etc/my.cnf)
# and enter
# [client]
# default-character-set = utf8
#

#######################################################################
#  Query config:  Username
#######################################################################
# This is the username that will get substituted, escaped, and added
# as attribute 'SQL-User-Name'. '%{SQL-User-Name}' should be used below
# everywhere a username substitution is needed so you you can be sure
# the username passed from the client is escaped properly.
#
# Uncomment the next line, if you want the sql_user_name to mean:
#
#	Use Stripped-User-Name, if it's there.
#	Else use User-Name, if it's there,
#	Else use hard-coded string "DEFAULT" as the user name.
#sql_user_name = "%{%{Stripped-User-Name}:-%{%{User-Name}:-DEFAULT}}"
#
sql_user_name = "%{User-Name}"

#######################################################################
#  Query config:  Event-Timestamp
#######################################################################
# event_timestamp_epoch is the basis for the time inserted into
# accounting records. Typically this will be the Event-Timestamp of the
# accounting request, which is usually provided by a NAS.
#
# Uncomment the next line, if you want the timestamp to be based on the
# request reception time recorded by this server, for example if you
# distrust the provided Event-Timestamp.
#event_timestamp_epoch = "%l"

event_timestamp_epoch = "%{%{integer:Event-Timestamp}:-%l}"

# event_timestamp is the SQL snippet for converting an epoch timestamp
# to an SQL date.

event_timestamp = "FROM_UNIXTIME(${event_timestamp_epoch})"

#######################################################################
# Accounting and Post-Auth Queries
#######################################################################
# These queries insert/update accounting and authentication records.
# The query to use is determined by the value of 'reference'.
# This value is used as a configuration path and should resolve to one
# or more 'query's. If reference points to multiple queries, and a query
# fails, the next query is executed.
#
# Behaviour is identical to the old 1.x/2.x module, except we can now
# fail between N queries, and query selection can be based on any
# combination of attributes, or custom 'Acct-Status-Type' values.
#######################################################################
accounting {
	reference = "%{tolower:type.%{%{Acct-Status-Type}:-%{Request-Processing-Stage}}.query}"

	# Write SQL queries to a logfile. This is potentially useful for bulk inserts
	# when used with the rlm_sql_null driver.
#	logfile = ${logdir}/accounting.sql

	type {
		accounting-on {
			#
			#  Bulk terminate all sessions associated with a given NAS
			#
			query = "\
				UPDATE ${....accounting_table} \
					SET \
						session_termination_cause = FROM_UNIXTIME(%{integer:Event-Timestamp}), \
						last_seen_datetime = '%{%{Acct-Terminate-Cause}:-Radius Server Reboot}'"
		}

		accounting-off {
			query = "${..accounting-on.query}"
		}

		#
		#  Implement the "sql_session_start" policy.
		#  See raddb/policy.d/accounting for more details.
		#
		#  You also need to fix the other queries as
		#  documented below.  Look for "sql_session_start".
		#
		post-auth {
			query = "\
			INSERT INTO ${....accounting_table} ( \
				mac_address, \
    			user_name, \
				ap_id, \
				client_ip, \
				first_seen_datetime, \
				last_seen_datetime, \
				input_bytes_session, \
				output_bytes_session, \
				session_termination_cause) \
				VALUES( \
					'%{Calling-Station-Id}', \
					'%{User-Name}', \
					'%{Called-Station-Id}', \
					'%{Framed-IP-Address}', \
					FROM_UNIXTIME(%{integer:Event-Timestamp}), \
					NULL, \
					'%{%{Acct-Input-Gigawords}:-0}' << 32 | '%{%{Acct-Input-Octets}:-0}', \
					'%{%{Acct-Output-Gigawords}:-0}' << 32 | '%{%{Acct-Output-Octets}:-0}', \
					'%{Acct-Terminate-Cause}');"
		}

		start {
			#
			#  Insert a new record into the sessions table
			#
			query = "\
			INSERT INTO ${....accounting_table} ( \
				mac_address, \
    			user_name, \
				ap_id, \
				client_ip, \
				first_seen_datetime, \
				last_seen_datetime, \
				input_bytes_session, \
				output_bytes_session, \
				session_termination_cause) \
				VALUES( \
					'%{Calling-Station-Id}', \
					'%{User-Name}', \
					'%{Called-Station-Id}', \
					'%{Framed-IP-Address}', \
					FROM_UNIXTIME(%{integer:Event-Timestamp}), \
					NULL, \
					'%{%{Acct-Input-Gigawords}:-0}' << 32 | '%{%{Acct-Input-Octets}:-0}', \
					'%{%{Acct-Output-Gigawords}:-0}' << 32 | '%{%{Acct-Output-Octets}:-0}', \
					'%{Acct-Terminate-Cause}');"

			#
			#  Key constraints prevented us from inserting a new session,
			#  use the alternate query to update an existing session.
			#
			
			query = "\
				UPDATE ${....accounting_table} \
				SET \
					ap_id = '%{Called-Station-Id}', \
					client_ip = '%{Framed-IP-Address}', \
					last_seen_datetime = FROM_UNIXTIME(%{integer:Event-Timestamp}), \
					input_bytes_session = '%{%{Acct-Input-Octets}:-0}', \
					output_bytes_session = '%{%{Acct-Output-Octets}:-0}', \
					session_termination_cause = '%{Acct-Terminate-Cause}' \
				WHERE mac_address = '%{Calling-Station-Id}';"

		}

		interim-update {
			#
			#  Update an existing session and calculate the interval
			#  between the last data we received for the session and this
			#  update. This can be used to find stale sessions.
			#
			query = "\
				UPDATE ${....accounting_table} \
				SET \
					ap_id = '%{Called-Station-Id}', \
					client_ip = '%{Framed-IP-Address}', \
					last_seen_datetime = FROM_UNIXTIME(%{integer:Event-Timestamp}), \
					input_bytes_session = '%{%{Acct-Input-Octets}:-0}', \
					output_bytes_session = '%{%{Acct-Output-Octets}:-0}', \
					session_termination_cause = '%{Acct-Terminate-Cause}' \
				WHERE mac_address = '%{Calling-Station-Id}';"

			#
			#  The update condition matched no existing sessions. Use
			#  the values provided in the update to create a new session.
			#
			query = "\
				INSERT INTO ${....accounting_table}( \
					mac_address, \
    				user_name, \
					ap_id, \
					client_ip, \
					first_seen_datetime, \
					last_seen_datetime, \
					input_bytes_session, \
					output_bytes_session, \
					session_termination_cause) \
					VALUES( \
						'%{Calling-Station-Id}', \
						'%{User-Name}', \
						'%{Called-Station-Id}', \
						'%{Framed-IP-Address}', \
						FROM_UNIXTIME(%{integer:Event-Timestamp}), \
						NULL, \
						'%{%{Acct-Input-Gigawords}:-0}' << 32 | '%{%{Acct-Input-Octets}:-0}', \
						'%{%{Acct-Output-Gigawords}:-0}' << 32 | '%{%{Acct-Output-Octets}:-0}', \
						'%{Acct-Terminate-Cause}');"

		}

		stop {
			#
			#  Session has terminated, update the stop time and statistics.
			#
			query = "\
				UPDATE ${....accounting_table} \
				SET \
					ap_id = '%{Called-Station-Id}', \
					client_ip = '%{Framed-IP-Address}', \
					last_seen_datetime = FROM_UNIXTIME(%{integer:Event-Timestamp}), \
					input_bytes_session = '%{%{Acct-Input-Octets}:-0}', \
					output_bytes_session = '%{%{Acct-Output-Octets}:-0}', \
					session_termination_cause = '%{Acct-Terminate-Cause}' \
				WHERE mac_address = '%{Calling-Station-Id}';"

			#
			#  The update condition matched no existing sessions. Use
			#  the values provided in the update to create a new session.
			#
			query = "\
				INSERT INTO ${....accounting_table}( \
					mac_address, \
    				user_name, \
					ap_id, \
					client_ip, \
					first_seen_datetime, \
					last_seen_datetime, \
					input_bytes_session, \
					output_bytes_session, \
					session_termination_cause) \
					VALUES( \
						'%{Called-Station-Id}', \
						'%{User-Name}', \
						'%{Framed-IP-Address}', \
						FROM_UNIXTIME(%{integer:Event-Timestamp}), \
						'%{integer:Event-Timestamp}', \
						'%{%{Acct-Input-Gigawords}:-0}' << 32 | '%{%{Acct-Input-Octets}:-0}', \
						'%{%{Acct-Output-Gigawords}:-0}' << 32 | '%{%{Acct-Output-Octets}:-0}', \
						'%{Acct-Terminate-Cause}');"

		}

		#
		#  No Acct-Status-Type == ignore the packet
		#
		accounting {
			query = "SELECT true"
		}
	}
}