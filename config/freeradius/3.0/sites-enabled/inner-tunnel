# -*- text -*-
######################################################################
#
#	This is a virtual server that handles *only* inner tunnel
#	requests for EAP-TTLS and PEAP types.
#
#	$Id: 10eeb55db7a1129ea62f2195c17b286eb4acd1d2 $
#
######################################################################

server inner-tunnel {

#
#  This next section is here to allow testing of the "inner-tunnel"
#  authentication methods, independently from the "default" server.
#  It is listening on "localhost", so that it can only be used from
#  the same machine.
#
#	$ radtest USER PASSWORD 127.0.0.1:18120 0 testing123
#
#  If it works, you have configured the inner tunnel correctly.  To check
#  if PEAP will work, use:
#
#	$ radtest -t mschap USER PASSWORD 127.0.0.1:18120 0 testing123
#
#  If that works, PEAP should work.  If that command doesn't work, then
#
#	FIX THE INNER TUNNEL CONFIGURATION SO THAT IT WORKS.
#
#  Do NOT do any PEAP tests.  It won't help.  Instead, concentrate
#  on fixing the inner tunnel configuration.  DO NOTHING ELSE.
#
listen {
       ipaddr = 127.0.0.1
       port = 18120
       type = auth
}

authorize {

	#
	#  Take a User-Name, and perform some checks on it, for spaces and other
	#  invalid characters.  If the User-Name appears invalid, reject the
	#  request.
	#
	#  See policy.d/filter for the definition of the filter_username policy.
	#
	filter_username

	#
	#  Do checks on outer / inner User-Name, so that users
	#  can't spoof us by using incompatible identities
	#
	filter_inner_identity

	#Rewrite calling station id syntax
	rewrite_calling_station_id

	#
	#   Checks User Permissions
	#  See policy.d/check_user_permissions for the definition of the check_user_permissions policy.
	#
	check_user_permissions

	#
	#  If the users are logging in with an MS-CHAP-Challenge
	#  attribute for authentication, the mschap module will find
	#  the MS-CHAP-Challenge attribute, and add 'Auth-Type := MS-CHAP'
	#  to the request, which will cause the server to then use
	#  the mschap module for authentication.
	mschap

	#
	#  This module takes care of EAP-MSCHAPv2 authentication.
	#
	#  It also sets the EAP-Type attribute in the request
	#  attribute list to the EAP type from the packet.
	#
	#  The example below uses module failover to avoid querying all
	#  of the following modules if the EAP module returns "ok".
	#  Therefore, your LDAP and/or SQL servers will not be queried
	#  for the many packets that go back and forth to set up TTLS
	#  or PEAP.  The load on those servers will therefore be reduced.
	#
	eap {
		ok = return
	}

	#
	#	IF Username EXISTS
	#   Sets password field to pass to CHAP
	#  	See policy.d/check_credentials for the definition of the check_credentials policy.
	#
	check_credentials
}


authenticate {

    #
	#  ### MS-CHAP authentication
	#
	#  For users who are using MS-CHAP authentication. A back-end
	#  database listed in the "recv Access-Request" section MUST supply
	#  either a Password.Cleartext attribute, or an NT-Password
	#  attribute. Encrypted passwords won't work.
	#
    Auth-Type MS-CHAP {
         mschap
    }
        
	#
	#  For old names, too.
	#
	mschap

	#
	#  For EAP, ensure that the Access-Accept contains a User-Name
	#  attribute.
	#
	eap

	#
	#  ### PAP Authentication
	#
	#  For users who are using PAP authentication. A back-end database
	#  listed in the "recv Access-Request" section MUST supply a "known
	#  good" password for the user.  The password can be clear-text, or
	#  encrypted via `crypt`, `bcrypt`, or other hashing.
	#
    Auth-Type PAP {
         pap
    }
        
}

#  Post-Authentication
post-auth {

	#
	#  If you want the Access-Accept to contain the inner
	#  User-Name, uncomment the following lines.
	#
	update outer.session-state {
	       User-Name := &User-Name
	}

	#
	#	POST-Auth Query to LOG reply
	#
	log_user

	#
	#  Instead of "use_tunneled_reply", change this "if (0)" to an
	#  "if (1)".
	#
	if (1) {
		#  Instead of "use_tunneled_reply", uncomment the
		#  next two "update" blocks.
		#
		update {
				&outer.session-state: += &reply:
		}

		#
		#  These attributes are for the inner session only.
		#  They MUST NOT be sent in the outer reply.
		#
		#  If you uncomment the previous block and leave
		#  this one commented out, WiFi WILL NOT WORK,
		#  because the client will get two MS-MPPE-keys
		#
		update outer.session-state {
				MS-MPPE-Encryption-Policy !* ANY
				MS-MPPE-Encryption-Types !* ANY
				MS-MPPE-Send-Key !* ANY
				MS-MPPE-Recv-Key !* ANY
				Message-Authenticator !* ANY
				EAP-Message !* ANY
				Proxy-State !* ANY
		}
	}

	Post-Auth-Type REJECT {
		attr_filter.access_reject

		#
		#  Let the outer session know which module failed, and why.
		#
		update outer.session-state {
			&Module-Failure-Message := &request:Module-Failure-Message
		}
	}
}

post-proxy {
	eap
}

} # inner-tunnel server block
